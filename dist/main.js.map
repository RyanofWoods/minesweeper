{"version":3,"sources":["webpack://minesweeper/./lib/generate_tiles.js","webpack://minesweeper/./lib/check_tiles.js","webpack://minesweeper/./lib/minesweeper.js"],"names":["tableBody","document","getElementById","wrap","header","tileRowHtml","xTiles","rowHtml","step","yTiles","mines","mineArray","running","flags","seconds","tilesClicked","table","querySelector","flagDigits","querySelectorAll","timerDigits","face","displayDigits","elements","number","numberStr","toString","padStart","position","i","parseInt","style","backgroundPositionX","updateFlagCounter","updateTimer","showMines","isWin","row","col","rows","cells","classList","add","searchCheck","searchAdjacent","tile","nearbyMines","contains","count","parentNode","rowIndex","cellIndex","rowOffset","colOffset","checkRow","checkCol","countNearbyMines","remove","markOpened","tileClick","event","currentTarget","button","noBombOnTileRow","noBombOnTileCol","push","minesLeft","randRow","Math","floor","random","randCol","generateMines","checkTile","toggle","toggleFlag","win","checkForWin","addEventListener","setInterval","difficultyElem","tiles","initiate","difficulty","value","data","innerHTML","insertAdjacentHTML","width","forEach","preventDefault"],"mappings":"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","file":"main.js","sourcesContent":["const tableBody = document.getElementById('minesweeper');\nconst wrap = document.getElementById('table-wrap');\nconst header = document.getElementById('minesweeper-header');\n\nconst tileRowHtml = (xTiles) => {\n  // create a row of cells html\n  let rowHtml = '<tr>';\n\n  for (let step = 1; step <= xTiles; step += 1) {\n    rowHtml += '<td class=\"unopened\"></td>';\n  }\n  rowHtml += '</tr>';\n  return rowHtml;\n};\n\nconst generateTiles = (xTiles, yTiles) => {\n  // clear inner table cells\n  tableBody.innerHTML = '';\n  // create rows based on given number (xTiles * xTiles)\n  for (let step = 1; step <= yTiles; step += 1) {\n    // Runs 5 times, with values of step 0 through 4.\n    tableBody.insertAdjacentHTML('beforeend', tileRowHtml(xTiles));\n  }\n  header.style.width = `${xTiles * 24 + 6}px`;\n  wrap.style.width = `${xTiles * 24 + 6}px`;\n};\n\nexport default generateTiles;\n","// pre-initialise all variables\nlet xTiles = 0;\nlet yTiles = 0;\nlet mines = 0;\nlet mineArray = [];\nlet running = false;\nlet flags = 99;\nlet seconds = 0;\nlet tilesClicked = 0;\n\nconst table = document.querySelector('table');\nconst flagDigits = document.querySelectorAll('#flags_left div');\nconst timerDigits = document.querySelectorAll('#timer div');\nconst face = document.getElementById('face');\n\nconst displayDigits = (elements, number) => {\n  const numberStr = number.toString(10).padStart(3, '0');\n  let position = 0;\n\n  for (let i = 0; i < 3; i += 1) {\n    position = parseInt(numberStr[i], 10) * 13;\n    // eslint-disable-next-line no-param-reassign\n    elements[i].style.backgroundPositionX = `-${position}px`;\n  }\n};\n\nconst updateFlagCounter = () => {\n  displayDigits(flagDigits, flags);\n};\n\nconst updateTimer = () => {\n  if (running === true && seconds < 999) {\n    seconds += 1;\n    displayDigits(timerDigits, seconds);\n  }\n};\n\nconst loadGame = (data) => {\n  // reset all variables\n  mines = data.mines;\n  xTiles = data.xTiles;\n  yTiles = data.yTiles;\n  flags = mines;\n  running = false;\n  seconds = 0;\n  tilesClicked = 0;\n  mineArray = [];\n  updateTimer();\n  updateFlagCounter();\n  face.classList.add('facesmile');\n  face.classList.remove('facewin');\n  face.classList.remove('facedead');\n};\n\nconst generateMines = (tile) => {\n  const noBombOnTileRow = tile.parentNode.rowIndex;\n  const noBombOnTileCol = tile.cellIndex;\n\n  // initialise an an array of xTiles * xTiles array with no mines\n  for (let row = 0; row < yTiles; row += 1) {\n    mineArray[row] = [];\n    for (let col = 0; col < xTiles; col += 1) {\n      mineArray[row].push(false);\n    }\n  }\n\n  let minesLeft = mines;\n\n  do {\n    const randRow = Math.floor(Math.random() * yTiles);\n    const randCol = Math.floor(Math.random() * xTiles);\n\n    // if the random tile does not equal our clicked tile\n    // check if there is a bomb there already\n    if (randRow !== noBombOnTileRow || randCol !== noBombOnTileCol) {\n      if (mineArray[randRow][randCol] === false) {\n        mineArray[randRow][randCol] = true;\n        minesLeft -= 1;\n      }\n    }\n  } while (minesLeft > 0);\n};\n\nconst markOpened = (tile) => {\n  tile.classList.remove('unopened');\n  tile.classList.add('opened');\n};\n\nconst toggleFlag = (tile) => {\n  // if it's unopened toggle the flag\n  if (tile.classList.contains('unopened') && flags >= 0) {\n    // if there is a flag, remove it and get the counter back\n    if (tile.classList.contains('flagged')) {\n      tile.classList.toggle('flagged');\n      flags += 1;\n      // else check we have more than zero flags and add one\n    } else if (flags > 0) {\n      tile.classList.toggle('flagged');\n      flags -= 1;\n    }\n  }\n  updateFlagCounter();\n};\n\nconst showMines = (isWin) => {\n  // iterate over every tile\n  for (let row = 0; row < yTiles; row += 1) {\n    for (let col = 0; col < xTiles; col += 1) {\n      // if there is a bomb there\n      if (mineArray[row][col] === true) {\n        // add a flag if won, otherwise show the mines on loss\n        if (isWin) {\n          table.rows[row].cells[col].classList.add('flagged');\n          flags = 0;\n          updateFlagCounter();\n        } else {\n          table.rows[row].cells[col].classList.add('mine');\n        }\n      }\n    }\n  }\n};\n\nconst gameOver = () => {\n  running = false;\n  face.classList.remove('facesmile');\n  face.classList.add('facedead');\n  showMines(false);\n};\n\nconst countNearbyMines = (tile) => {\n  if (tile.classList.contains('opened')) return false;\n\n  let count = 0;\n  const row = tile.parentNode.rowIndex;\n  const col = tile.cellIndex;\n\n  // search the surrounding 8 tiles (search includes clicked tile)\n  for (let rowOffset = -1; rowOffset < 2; rowOffset += 1) {\n    for (let colOffset = -1; colOffset < 2; colOffset += 1) {\n      // given tile offsetted by loop\n      const checkRow = row + rowOffset;\n      const checkCol = col + colOffset;\n\n      // prevent errors by skipping rows/cols less than 0 and more than xTiles - 1\n      if (checkRow >= 0 && checkRow <= yTiles - 1 && checkCol >= 0 && checkCol <= xTiles - 1) {\n        // if there is a bomb there, increment the count\n        if (mineArray[checkRow][checkCol]) {\n          count += 1;\n        }\n      }\n    }\n  }\n  return count;\n};\n\nconst searchCheck = (row, col) => {\n  // check to see if the tile exists\n  if (row >= 0 && row < yTiles && col >= 0 && col < xTiles) {\n    // eslint-disable-next-line no-use-before-define\n    searchAdjacent(table.rows[row].cells[col]);\n  }\n};\n\nconst searchAdjacent = (tile) => {\n  const nearbyMines = countNearbyMines(tile);\n  if (nearbyMines === false) return;\n\n  // if the tile has no nearby mines => recurse (cascade)\n  // searchCheck checks if the tile exists before recursion\n  if (nearbyMines === 0) {\n    markOpened(tile);\n\n    const row = tile.parentNode.rowIndex;\n    const col = tile.cellIndex;\n\n    searchCheck(row - 1, col - 1); // up left\n    searchCheck(row - 1, col); // up\n    searchCheck(row - 1, col + 1); // up right\n\n    searchCheck(row, col - 1); // left\n    searchCheck(row, col + 1); // right\n\n    searchCheck(row + 1, col - 1); // down left\n    searchCheck(row + 1, col); // down\n    searchCheck(row + 1, col + 1); // down right\n  } else {\n    // otherwise display number\n    tile.classList.add(`mine-neighbour-${nearbyMines}`);\n    tile.classList.remove('unopened');\n  }\n};\n\nconst checkForWin = () => {\n  let win = true;\n\n  // iterate over every row and then cell\n  // based on xtiles\n  for (let row = 0; row < yTiles; row += 1) {\n    for (let col = 0; col < xTiles; col += 1) {\n      // every tile should be not unopened unless there is a bomb there\n      if (table.rows[row].cells[col].classList.contains('unopened') && mineArray[row][col] === false) {\n        win = false;\n      }\n      if (win === false) break;\n    }\n    if (win === false) break;\n  }\n  // if won, stop timer and put shades on\n  if (win) {\n    running = false;\n    face.classList.remove('facesmile');\n    face.classList.add('facewin');\n    showMines(true);\n  }\n};\n\nconst checkTile = (tile) => {\n  const row = tile.parentNode.rowIndex;\n  const col = tile.cellIndex;\n\n  // check for a bomb\n  if (mineArray[row][col] === true) {\n    tile.classList.add('mine');\n    gameOver();\n  } else {\n    searchAdjacent(tile);\n  }\n};\n\nconst tileClick = (event) => {\n  // start the game\n  if (tilesClicked === 0) running = true;\n\n  // on loss stop actions\n  if (!running) return;\n\n  const tile = event.currentTarget;\n\n  // left click\n  if (event.button === 0) {\n    // prevent left clicking on flagged tiles\n    if (tile.classList.contains('flagged')) return;\n    tilesClicked += 1;\n\n    if (tilesClicked === 1) {\n      // mines should be generated after first click to guarantee first move\n      generateMines(tile);\n      searchAdjacent(tile);\n    } else {\n      checkTile(tile);\n    }\n  // right click\n  } else if (event.button === 2) {\n    // right click\n    toggleFlag(tile);\n  }\n\n  checkForWin();\n};\n\ndocument.addEventListener('DOMContentLoaded', () => {\n  setInterval(updateTimer, 1000); // Every 1 second, update the timer\n});\n\nexport { loadGame, tileClick };\n","import generateTiles from './generate_tiles';\nimport { loadGame, tileClick } from './check_tiles';\n\nconst table = document.querySelector('table');\nconst face = document.getElementById('face');\nconst difficultyElem = document.getElementById('difficulty');\nlet tiles;\nlet xTiles;\nlet yTiles;\nlet mines;\n\nconst initiate = () => {\n  const difficulty = difficultyElem.value;\n\n  if (difficulty === 'beginner') {\n    xTiles = 9;\n    yTiles = 9;\n    mines = 10;\n  } else if (difficulty === 'intermediate') {\n    xTiles = 16;\n    yTiles = 16;\n    mines = 40;\n  } else if (difficulty === 'expert') {\n    xTiles = 30;\n    yTiles = 16;\n    mines = 99;\n  }\n\n  loadGame({ xTiles, yTiles, mines });\n  generateTiles(xTiles, yTiles);\n\n  // The tiles must be captured after initiation!!\n  tiles = document.querySelectorAll('#minesweeper td');\n\n  tiles.forEach((tile) => {\n    tile.addEventListener('mouseup', (event) => {\n      face.classList.remove('facesuprised');\n      tileClick(event);\n    });\n    // imitate tile pressed\n    tile.addEventListener('mousedown', (event) => {\n      if (event.button === 0) {\n        tile.classList.add('pressed');\n        face.classList.add('facesuprised');\n      }\n    });\n    tile.addEventListener('mouseleave', () => {\n      tile.classList.remove('pressed');\n    });\n  });\n};\n\ntable.addEventListener('contextmenu', (event) => {\n  event.preventDefault();\n}, false);\n\n// clicking the face\nface.addEventListener('click', (event) => {\n  // restart the game\n  if (event.button === 0) {\n    face.classList.remove('facepressed');\n    initiate();\n  }\n});\nface.addEventListener('mousedown', (event) => {\n  if (event.button === 0) {\n    face.classList.add('facepressed');\n  }\n});\nface.addEventListener('mouseleave', (event) => {\n  if (event.button === 0) {\n    face.classList.remove('facepressed');\n  }\n});\n\ninitiate();\n"],"sourceRoot":""}